from fastapi import FastAPI, APIRouter, HTTPException, Depends, status
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from dotenv import load_dotenv
from starlette.middleware.cors import CORSMiddleware
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from typing import List, Optional, Dict
import uuid
from datetime import datetime, timezone, timedelta
import hashlib
import jwt
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

mongo_url = os.environ['MONGO_URL']
client = AsyncIOMotorClient(mongo_url)
db = client[os.environ['DB_NAME']]

# JWT Settings
JWT_SECRET = os.environ.get('JWT_SECRET', 'your-secret-key-change-in-production')
JWT_ALGORITHM = "HS256"
JWT_EXPIRATION_HOURS = 24

# SMTP Email Settings
SMTP_HOST = os.environ.get('SMTP_HOST', '')
SMTP_PORT = int(os.environ.get('SMTP_PORT', '587'))
SMTP_USER = os.environ.get('SMTP_USER', '')
SMTP_PASSWORD = os.environ.get('SMTP_PASSWORD', '')
SMTP_FROM_EMAIL = os.environ.get('SMTP_FROM_EMAIL', '')
SMTP_FROM_NAME = os.environ.get('SMTP_FROM_NAME', 'YASH EstiPro')

security = HTTPBearer(auto_error=False)

app = FastAPI()
api_router = APIRouter(prefix="/api")


# User Models
class User(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    email: str
    password_hash: str
    name: str
    role: str = "user"  # user, approver, admin
    is_active: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class UserRegister(BaseModel):
    email: str
    password: str
    name: str

class UserLogin(BaseModel):
    email: str
    password: str

class UserResponse(BaseModel):
    id: str
    email: str
    name: str
    role: str
    is_active: bool = True

class UserCreate(BaseModel):
    email: str
    password: str
    name: str
    role: str = "user"

class UserUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None
    role: Optional[str] = None
    is_active: Optional[bool] = None

class AuthResponse(BaseModel):
    token: str
    user: UserResponse


# User Settings Model
class UserSettings(BaseModel):
    model_config = ConfigDict(extra="ignore")
    user_id: str
    theme: str = "light"
    custom_theme_image: str = ""
    date_format: str = "MM/DD/YYYY"
    number_format: str = "en-US"
    currency: str = "USD"
    compact_numbers: bool = True
    show_grid_lines: bool = True
    default_profit_margin: float = 35
    default_contingency: float = 5


def hash_password(password: str) -> str:
    return hashlib.sha256(password.encode()).hexdigest()

def create_jwt_token(user_id: str, email: str) -> str:
    payload = {
        "user_id": user_id,
        "email": email,
        "exp": datetime.now(timezone.utc) + timedelta(hours=JWT_EXPIRATION_HOURS)
    }
    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALGORITHM)

def verify_jwt_token(token: str) -> Optional[dict]:
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        return None
    except jwt.InvalidTokenError:
        return None

async def get_current_user(credentials: HTTPAuthorizationCredentials = Depends(security)) -> Optional[dict]:
    if not credentials:
        return None
    payload = verify_jwt_token(credentials.credentials)
    if not payload:
        return None
    return payload

async def require_auth(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
    if not credentials:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    payload = verify_jwt_token(credentials.credentials)
    if not payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired token")
    return payload

async def require_admin(credentials: HTTPAuthorizationCredentials = Depends(security)) -> dict:
    """Require admin role for access"""
    if not credentials:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Not authenticated")
    payload = verify_jwt_token(credentials.credentials)
    if not payload:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired token")
    
    # Check if user is admin
    user = await db.users.find_one({"id": payload["user_id"]}, {"_id": 0})
    if not user or user.get("role") != "admin":
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Admin access required")
    return payload


# Auth Endpoints
@api_router.post("/auth/register", response_model=AuthResponse)
async def register(data: UserRegister):
    # Check if email already exists
    existing = await db.users.find_one({"email": data.email.lower()})
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    user = User(
        email=data.email.lower(),
        password_hash=hash_password(data.password),
        name=data.name
    )
    await db.users.insert_one(user.model_dump())
    
    token = create_jwt_token(user.id, user.email)
    return AuthResponse(
        token=token,
        user=UserResponse(id=user.id, email=user.email, name=user.name, role=user.role)
    )

@api_router.post("/auth/login", response_model=AuthResponse)
async def login(data: UserLogin):
    user_doc = await db.users.find_one({"email": data.email.lower()})
    if not user_doc:
        raise HTTPException(status_code=401, detail="Invalid email or password")
    
    if user_doc["password_hash"] != hash_password(data.password):
        raise HTTPException(status_code=401, detail="Invalid email or password")
    
    token = create_jwt_token(user_doc["id"], user_doc["email"])
    return AuthResponse(
        token=token,
        user=UserResponse(
            id=user_doc["id"],
            email=user_doc["email"],
            name=user_doc["name"],
            role=user_doc.get("role", "user"),
            is_active=user_doc.get("is_active", True)
        )
    )

@api_router.get("/auth/me", response_model=UserResponse)
async def get_me(user: dict = Depends(require_auth)):
    user_doc = await db.users.find_one({"id": user["user_id"]})
    if not user_doc:
        raise HTTPException(status_code=404, detail="User not found")
    return UserResponse(
        id=user_doc["id"],
        email=user_doc["email"],
        name=user_doc["name"],
        role=user_doc.get("role", "user"),
        is_active=user_doc.get("is_active", True)
    )


# User Management Endpoints (Admin only)
@api_router.get("/users", response_model=List[UserResponse])
async def get_all_users(user: dict = Depends(require_auth)):
    """Get all users - Admin only"""
    current_user = await db.users.find_one({"id": user["user_id"]})
    if not current_user or current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    users = await db.users.find({}, {"_id": 0, "password_hash": 0}).to_list(1000)
    return [UserResponse(
        id=u["id"],
        email=u["email"],
        name=u["name"],
        role=u.get("role", "user"),
        is_active=u.get("is_active", True)
    ) for u in users]

@api_router.post("/users", response_model=UserResponse)
async def create_user(data: UserCreate, user: dict = Depends(require_auth)):
    """Create a new user - Admin only"""
    current_user = await db.users.find_one({"id": user["user_id"]})
    if not current_user or current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    # Check if email already exists
    existing = await db.users.find_one({"email": data.email.lower()})
    if existing:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    if data.role not in ["user", "approver", "admin"]:
        raise HTTPException(status_code=400, detail="Invalid role. Must be: user, approver, or admin")
    
    new_user = User(
        email=data.email.lower(),
        password_hash=hash_password(data.password),
        name=data.name,
        role=data.role
    )
    await db.users.insert_one(new_user.model_dump())
    
    return UserResponse(
        id=new_user.id,
        email=new_user.email,
        name=new_user.name,
        role=new_user.role,
        is_active=new_user.is_active
    )

@api_router.put("/users/{user_id}", response_model=UserResponse)
async def update_user(user_id: str, data: UserUpdate, user: dict = Depends(require_auth)):
    """Update a user - Admin only"""
    current_user = await db.users.find_one({"id": user["user_id"]})
    if not current_user or current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    target_user = await db.users.find_one({"id": user_id})
    if not target_user:
        raise HTTPException(status_code=404, detail="User not found")
    
    update_data = {}
    if data.name is not None:
        update_data["name"] = data.name
    if data.email is not None:
        # Check if email already taken by another user
        existing = await db.users.find_one({"email": data.email.lower(), "id": {"$ne": user_id}})
        if existing:
            raise HTTPException(status_code=400, detail="Email already in use")
        update_data["email"] = data.email.lower()
    if data.role is not None:
        if data.role not in ["user", "approver", "admin"]:
            raise HTTPException(status_code=400, detail="Invalid role")
        update_data["role"] = data.role
    if data.is_active is not None:
        update_data["is_active"] = data.is_active
    
    if update_data:
        await db.users.update_one({"id": user_id}, {"$set": update_data})
    
    updated_user = await db.users.find_one({"id": user_id})
    return UserResponse(
        id=updated_user["id"],
        email=updated_user["email"],
        name=updated_user["name"],
        role=updated_user.get("role", "user"),
        is_active=updated_user.get("is_active", True)
    )

@api_router.delete("/users/{user_id}")
async def delete_user(user_id: str, user: dict = Depends(require_auth)):
    """Delete a user - Admin only"""
    current_user = await db.users.find_one({"id": user["user_id"]})
    if not current_user or current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    if user_id == user["user_id"]:
        raise HTTPException(status_code=400, detail="Cannot delete yourself")
    
    result = await db.users.delete_one({"id": user_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="User not found")
    
    return {"message": "User deleted successfully"}


@api_router.get("/users/approvers/list")
async def get_approvers(user: dict = Depends(get_current_user)):
    """Get list of users who can approve projects (approvers and admins)"""
    approvers = await db.users.find(
        {
            "role": {"$in": ["approver", "admin"]},
            "is_active": {"$ne": False}
        },
        {"_id": 0, "id": 1, "email": 1, "name": 1, "role": 1}
    ).to_list(100)
    return approvers


@api_router.post("/users/{user_id}/reset-password")
async def reset_password(user_id: str, new_password: str, user: dict = Depends(require_auth)):
    """Reset a user's password - Admin only"""
    current_user = await db.users.find_one({"id": user["user_id"]})
    if not current_user or current_user.get("role") != "admin":
        raise HTTPException(status_code=403, detail="Admin access required")
    
    target_user = await db.users.find_one({"id": user_id})
    if not target_user:
        raise HTTPException(status_code=404, detail="User not found")
    
    if len(new_password) < 6:
        raise HTTPException(status_code=400, detail="Password must be at least 6 characters")
    
    await db.users.update_one(
        {"id": user_id},
        {"$set": {"password_hash": hash_password(new_password)}}
    )
    
    return {"message": "Password reset successfully"}


# User Settings Endpoints
@api_router.get("/user/settings")
async def get_user_settings(user: dict = Depends(require_auth)):
    """Get current user's settings"""
    settings = await db.user_settings.find_one({"user_id": user["user_id"]}, {"_id": 0})
    if not settings:
        # Return default settings
        return {
            "theme": "light",
            "customThemeImage": "",
            "dateFormat": "MM/DD/YYYY",
            "numberFormat": "en-US",
            "currency": "USD",
            "compactNumbers": True,
            "showGridLines": True,
            "defaultProfitMargin": 35,
            "defaultContingency": 5
        }
    # Convert snake_case to camelCase for frontend
    return {
        "theme": settings.get("theme", "light"),
        "customThemeImage": settings.get("custom_theme_image", ""),
        "dateFormat": settings.get("date_format", "MM/DD/YYYY"),
        "numberFormat": settings.get("number_format", "en-US"),
        "currency": settings.get("currency", "USD"),
        "compactNumbers": settings.get("compact_numbers", True),
        "showGridLines": settings.get("show_grid_lines", True),
        "defaultProfitMargin": settings.get("default_profit_margin", 35),
        "defaultContingency": settings.get("default_contingency", 5)
    }


@api_router.put("/user/settings")
async def update_user_settings(settings: dict, user: dict = Depends(require_auth)):
    """Update current user's settings"""
    # Convert camelCase to snake_case for storage
    settings_to_save = {
        "user_id": user["user_id"],
        "theme": settings.get("theme", "light"),
        "custom_theme_image": settings.get("customThemeImage", ""),
        "date_format": settings.get("dateFormat", "MM/DD/YYYY"),
        "number_format": settings.get("numberFormat", "en-US"),
        "currency": settings.get("currency", "USD"),
        "compact_numbers": settings.get("compactNumbers", True),
        "show_grid_lines": settings.get("showGridLines", True),
        "default_profit_margin": settings.get("defaultProfitMargin", 35),
        "default_contingency": settings.get("defaultContingency", 5)
    }
    
    await db.user_settings.update_one(
        {"user_id": user["user_id"]},
        {"$set": settings_to_save},
        upsert=True
    )
    
    return {"message": "Settings updated successfully"}


# Models for Customers
class Customer(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    location: str  # ISO country code
    location_name: str
    city: str = ""
    industry_vertical: str = ""
    sub_industry_vertical: str = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class CustomerCreate(BaseModel):
    name: str
    location: str
    location_name: str
    city: str = ""
    industry_vertical: str = ""
    sub_industry_vertical: str = ""


# Models for Technologies
class Technology(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    description: Optional[str] = ""
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class TechnologyCreate(BaseModel):
    name: str
    description: Optional[str] = ""


# Models for Project Types
class ProjectType(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ProjectTypeCreate(BaseModel):
    name: str


# Models for Base Locations
class BaseLocation(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    overhead_percentage: float
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class BaseLocationCreate(BaseModel):
    name: str
    overhead_percentage: float


# Models for Skills
class Skill(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    technology_id: str
    technology_name: str
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class SkillCreate(BaseModel):
    name: str
    technology_id: str
    technology_name: str


# Models for Proficiency Rates
class ProficiencyRate(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    skill_id: str
    skill_name: str
    technology_id: str
    technology_name: str
    base_location_id: str
    base_location_name: str
    proficiency_level: str
    avg_monthly_salary: float
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ProficiencyRateCreate(BaseModel):
    skill_id: str
    skill_name: str
    technology_id: str
    technology_name: str
    base_location_id: str
    base_location_name: str
    proficiency_level: str
    avg_monthly_salary: float


# Models for Wave Grid Allocation
class WaveGridAllocation(BaseModel):
    id: str = ""
    skill_id: str
    skill_name: str
    proficiency_level: str
    avg_monthly_salary: float  # Can be overridden per estimation
    original_monthly_salary: float = 0  # Original rate from master
    base_location_id: str
    base_location_name: str
    overhead_percentage: float
    is_onsite: bool = False
    travel_required: bool = False  # Indicates if travel logistics apply
    phase_allocations: Dict[str, float] = {}
    # Logistics costs - editable per resource (legacy fields, now calculated at wave level)
    per_diem_daily: float = 50
    per_diem_days: int = 30
    accommodation_daily: float = 80
    accommodation_days: int = 30
    local_conveyance_daily: float = 20
    local_conveyance_days: int = 21
    flight_cost_per_trip: float = 0
    visa_insurance_per_trip: float = 0
    num_trips: int = 0


# Models for Project Waves
class ProjectWave(BaseModel):
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    duration_months: float
    phase_names: List[str] = []  # User-defined phase names per month/column
    logistics_defaults: Dict[str, float] = {}  # Legacy - keeping for backwards compatibility
    logistics_config: Dict[str, float] = {}  # Logistics configuration for wave
    nego_buffer_percentage: float = 0  # Negotiation buffer percentage
    grid_allocations: List[WaveGridAllocation] = []


# Models for Projects
class Project(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    project_number: str = ""  # Unique project number like PRJ-0001
    version: int = 1  # Version number for tracking changes
    version_notes: str = ""  # Notes for this version
    name: str
    customer_id: str = ""
    customer_name: str = ""
    project_location: str = ""  # ISO country code (legacy single location)
    project_location_name: str = ""
    project_locations: List[str] = []  # Multiple ISO country codes
    project_location_names: List[str] = []  # Multiple location names
    technology_id: str = ""
    technology_name: str = ""
    technology_ids: List[str] = []  # Multiple technologies
    technology_names: List[str] = []
    project_type_id: str = ""
    project_type_name: str = ""
    project_type_ids: List[str] = []  # Multiple project types
    project_type_names: List[str] = []
    description: Optional[str] = ""
    profit_margin_percentage: float = 35.0
    waves: List[ProjectWave] = []
    is_latest_version: bool = True  # Flag to identify latest version
    parent_project_id: str = ""  # For version tracking - links to original project
    is_template: bool = False  # Flag to mark as template
    template_name: str = ""  # Name for the template
    # Approval workflow fields
    status: str = "draft"  # draft, in_review, approved, rejected
    approver_email: str = ""
    approval_comments: str = ""
    submitted_at: Optional[str] = None
    approved_at: Optional[str] = None
    submitted_by: str = ""
    approved_by: str = ""
    # Sales Manager
    sales_manager_id: str = ""
    sales_manager_name: str = ""
    # Audit fields
    created_by_id: str = ""  # User ID who created the project
    created_by_name: str = ""  # User name who created the project
    created_by_email: str = ""  # User email who created the project
    is_archived: bool = False  # Whether the project is archived
    archived_at: Optional[datetime] = None  # When the project was archived
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    updated_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))

class ProjectCreate(BaseModel):
    name: str
    customer_id: str = ""
    customer_name: str = ""
    project_location: str = ""
    project_location_name: str = ""
    project_locations: List[str] = []
    project_location_names: List[str] = []
    technology_id: str = ""
    technology_name: str = ""
    technology_ids: List[str] = []
    technology_names: List[str] = []
    project_type_id: str = ""
    project_type_name: str = ""
    project_type_ids: List[str] = []
    project_type_names: List[str] = []
    description: Optional[str] = ""
    profit_margin_percentage: float = 35.0
    waves: Optional[List[Dict]] = None
    version_notes: str = ""
    status: str = "draft"
    approver_email: str = ""
    sales_manager_id: str = ""
    sales_manager_name: str = ""

class ProjectUpdate(BaseModel):
    name: Optional[str] = None
    customer_id: Optional[str] = None
    customer_name: Optional[str] = None
    project_location: Optional[str] = None
    project_location_name: Optional[str] = None
    project_locations: Optional[List[str]] = None
    project_location_names: Optional[List[str]] = None
    technology_id: Optional[str] = None
    technology_name: Optional[str] = None
    technology_ids: Optional[List[str]] = None
    technology_names: Optional[List[str]] = None
    project_type_id: Optional[str] = None
    project_type_name: Optional[str] = None
    project_type_ids: Optional[List[str]] = None
    project_type_names: Optional[List[str]] = None
    description: Optional[str] = None
    profit_margin_percentage: Optional[float] = None
    waves: Optional[List[Dict]] = None
    version_notes: Optional[str] = None
    status: Optional[str] = None
    approver_email: Optional[str] = None
    approval_comments: Optional[str] = None
    sales_manager_id: Optional[str] = None
    sales_manager_name: Optional[str] = None

# Notification model
class Notification(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    user_email: str  # Who receives the notification
    type: str  # review_request, approved, rejected, revision_needed
    title: str
    message: str
    project_id: str
    project_number: str
    is_read: bool = False
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


# Audit Log Model
class AuditLog(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    user_id: str
    user_name: str
    user_email: str
    action: str  # created, updated, deleted, cloned, archived, unarchived, status_change, version_created
    entity_type: str  # project, wave, resource
    entity_id: str
    entity_name: str
    project_id: Optional[str] = None
    project_number: Optional[str] = None
    project_name: Optional[str] = None
    changes: Optional[List[Dict]] = None  # [{field: "", old_value: "", new_value: ""}]
    metadata: Optional[Dict] = None  # Additional context


# Helper function to create audit log
async def create_audit_log(
    user: dict,
    action: str,
    entity_type: str,
    entity_id: str,
    entity_name: str,
    project_id: str = None,
    project_number: str = None,
    project_name: str = None,
    changes: List[Dict] = None,
    metadata: Dict = None
):
    audit_log = AuditLog(
        user_id=user.get("id", ""),
        user_name=user.get("name", ""),
        user_email=user.get("email", ""),
        action=action,
        entity_type=entity_type,
        entity_id=entity_id,
        entity_name=entity_name,
        project_id=project_id,
        project_number=project_number,
        project_name=project_name,
        changes=changes,
        metadata=metadata
    )
    doc = audit_log.model_dump()
    doc['timestamp'] = doc['timestamp'].isoformat()
    await db.audit_logs.insert_one(doc)
    return audit_log


# Helper to detect field changes between old and new data
def detect_changes(old_data: dict, new_data: dict, fields_to_track: List[str]) -> List[Dict]:
    changes = []
    for field in fields_to_track:
        old_val = old_data.get(field)
        new_val = new_data.get(field)
        if old_val != new_val:
            changes.append({
                "field": field,
                "old_value": str(old_val) if old_val is not None else None,
                "new_value": str(new_val) if new_val is not None else None
            })
    return changes


# Email Helper Function
async def send_email(to_email: str, subject: str, html_body: str, text_body: str = None):
    """Send email via SMTP"""
    if not SMTP_HOST or not SMTP_USER:
        logging.warning("SMTP not configured, skipping email notification")
        return False
    
    try:
        msg = MIMEMultipart('alternative')
        msg['Subject'] = subject
        msg['From'] = f"{SMTP_FROM_NAME} <{SMTP_FROM_EMAIL}>"
        msg['To'] = to_email
        
        # Add plain text and HTML parts
        if text_body:
            msg.attach(MIMEText(text_body, 'plain'))
        msg.attach(MIMEText(html_body, 'html'))
        
        # Connect and send
        with smtplib.SMTP(SMTP_HOST, SMTP_PORT) as server:
            server.starttls()
            server.login(SMTP_USER, SMTP_PASSWORD)
            server.sendmail(SMTP_FROM_EMAIL, to_email, msg.as_string())
        
        logging.info(f"Email sent successfully to {to_email}")
        return True
    except Exception as e:
        logging.error(f"Failed to send email to {to_email}: {str(e)}")
        return False


# Email templates
def get_review_request_email(project_number: str, project_name: str, submitter_name: str, submitter_email: str):
    subject = f"[YASH EstiPro] Review Request: {project_number} - {project_name}"
    html_body = f"""
    <html>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%); padding: 20px; border-radius: 8px 8px 0 0;">
                <h1 style="color: #fff; margin: 0; font-size: 24px;">YASH EstiPro</h1>
            </div>
            <div style="background: #f8fafc; padding: 30px; border-radius: 0 0 8px 8px;">
                <h2 style="color: #0F172A; margin-top: 0;">New Project Review Request</h2>
                <p>A project has been submitted for your review:</p>
                <div style="background: #fff; padding: 20px; border-radius: 8px; border-left: 4px solid #0EA5E9; margin: 20px 0;">
                    <p style="margin: 5px 0;"><strong>Project:</strong> {project_number}</p>
                    <p style="margin: 5px 0;"><strong>Name:</strong> {project_name}</p>
                    <p style="margin: 5px 0;"><strong>Submitted by:</strong> {submitter_name} ({submitter_email})</p>
                </div>
                <p>Please log in to YASH EstiPro to review and approve/reject this project.</p>
                <p style="color: #64748b; font-size: 12px; margin-top: 30px;">
                    This is an automated message from YASH EstiPro. Please do not reply to this email.
                </p>
            </div>
        </div>
    </body>
    </html>
    """
    text_body = f"New Project Review Request\n\nProject: {project_number}\nName: {project_name}\nSubmitted by: {submitter_name} ({submitter_email})\n\nPlease log in to YASH EstiPro to review."
    return subject, html_body, text_body


def get_approval_email(project_number: str, project_name: str, status: str, approver_name: str, comments: str = ""):
    status_text = "Approved" if status == "approved" else "Rejected"
    status_color = "#10B981" if status == "approved" else "#EF4444"
    subject = f"[YASH EstiPro] Project {status_text}: {project_number} - {project_name}"
    html_body = f"""
    <html>
    <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
        <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
            <div style="background: linear-gradient(135deg, #0F172A 0%, #1E293B 100%); padding: 20px; border-radius: 8px 8px 0 0;">
                <h1 style="color: #fff; margin: 0; font-size: 24px;">YASH EstiPro</h1>
            </div>
            <div style="background: #f8fafc; padding: 30px; border-radius: 0 0 8px 8px;">
                <h2 style="color: {status_color}; margin-top: 0;">Project {status_text}</h2>
                <p>Your project has been <strong style="color: {status_color};">{status_text.lower()}</strong>:</p>
                <div style="background: #fff; padding: 20px; border-radius: 8px; border-left: 4px solid {status_color}; margin: 20px 0;">
                    <p style="margin: 5px 0;"><strong>Project:</strong> {project_number}</p>
                    <p style="margin: 5px 0;"><strong>Name:</strong> {project_name}</p>
                    <p style="margin: 5px 0;"><strong>Reviewed by:</strong> {approver_name}</p>
                    {f'<p style="margin: 5px 0;"><strong>Comments:</strong> {comments}</p>' if comments else ''}
                </div>
                <p>Log in to YASH EstiPro to view the details.</p>
                <p style="color: #64748b; font-size: 12px; margin-top: 30px;">
                    This is an automated message from YASH EstiPro. Please do not reply to this email.
                </p>
            </div>
        </div>
    </body>
    </html>
    """
    text_body = f"Project {status_text}\n\nProject: {project_number}\nName: {project_name}\nReviewed by: {approver_name}\n{f'Comments: {comments}' if comments else ''}"
    return subject, html_body, text_body


# Sales Manager Model
class SalesManager(BaseModel):
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    name: str
    email: str = ""
    phone: str = ""
    department: str = ""
    is_active: bool = True
    created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))


class SalesManagerCreate(BaseModel):
    name: str
    email: str = ""
    phone: str = ""
    department: str = ""
    is_active: bool = True


class SalesManagerUpdate(BaseModel):
    name: Optional[str] = None
    email: Optional[str] = None
    phone: Optional[str] = None
    department: Optional[str] = None
    is_active: Optional[bool] = None


# Customers Routes
@api_router.post("/customers", response_model=Customer)
async def create_customer(input: CustomerCreate):
    customer_obj = Customer(**input.model_dump())
    doc = customer_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.customers.insert_one(doc)
    return customer_obj

@api_router.get("/customers", response_model=List[Customer])
async def get_customers():
    customers = await db.customers.find({}, {"_id": 0}).to_list(1000)
    for customer in customers:
        if isinstance(customer['created_at'], str):
            customer['created_at'] = datetime.fromisoformat(customer['created_at'])
    return customers

@api_router.delete("/customers/{customer_id}")
async def delete_customer(customer_id: str):
    result = await db.customers.delete_one({"id": customer_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Customer not found")
    return {"message": "Customer deleted successfully"}


# Technologies Routes
@api_router.post("/technologies", response_model=Technology)
async def create_technology(input: TechnologyCreate):
    tech_obj = Technology(**input.model_dump())
    doc = tech_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.technologies.insert_one(doc)
    return tech_obj

@api_router.get("/technologies", response_model=List[Technology])
async def get_technologies():
    technologies = await db.technologies.find({}, {"_id": 0}).to_list(1000)
    for tech in technologies:
        if isinstance(tech['created_at'], str):
            tech['created_at'] = datetime.fromisoformat(tech['created_at'])
    return technologies

@api_router.delete("/technologies/{tech_id}")
async def delete_technology(tech_id: str):
    result = await db.technologies.delete_one({"id": tech_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Technology not found")
    return {"message": "Technology deleted successfully"}


# Project Types Routes
@api_router.post("/project-types", response_model=ProjectType)
async def create_project_type(input: ProjectTypeCreate):
    type_obj = ProjectType(**input.model_dump())
    doc = type_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.project_types.insert_one(doc)
    return type_obj

@api_router.get("/project-types", response_model=List[ProjectType])
async def get_project_types():
    types = await db.project_types.find({}, {"_id": 0}).to_list(1000)
    for ptype in types:
        if isinstance(ptype['created_at'], str):
            ptype['created_at'] = datetime.fromisoformat(ptype['created_at'])
    return types

@api_router.delete("/project-types/{type_id}")
async def delete_project_type(type_id: str):
    result = await db.project_types.delete_one({"id": type_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Project type not found")
    return {"message": "Project type deleted successfully"}


# Base Locations Routes
@api_router.post("/base-locations", response_model=BaseLocation)
async def create_base_location(input: BaseLocationCreate):
    location_obj = BaseLocation(**input.model_dump())
    doc = location_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.base_locations.insert_one(doc)
    return location_obj

@api_router.get("/base-locations", response_model=List[BaseLocation])
async def get_base_locations():
    locations = await db.base_locations.find({}, {"_id": 0}).to_list(1000)
    for location in locations:
        if isinstance(location['created_at'], str):
            location['created_at'] = datetime.fromisoformat(location['created_at'])
    return locations

@api_router.delete("/base-locations/{location_id}")
async def delete_base_location(location_id: str):
    result = await db.base_locations.delete_one({"id": location_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Base location not found")
    return {"message": "Base location deleted successfully"}


# Skills Routes
@api_router.post("/skills", response_model=Skill)
async def create_skill(input: SkillCreate):
    # Check for duplicate: same skill name + technology combination
    existing = await db.skills.find_one({
        "name": input.name,
        "technology_id": input.technology_id
    }, {"_id": 0})
    if existing:
        raise HTTPException(
            status_code=400, 
            detail=f"Skill '{input.name}' already exists for this technology"
        )
    
    skill_obj = Skill(**input.model_dump())
    doc = skill_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.skills.insert_one(doc)
    return skill_obj

@api_router.get("/skills", response_model=List[Skill])
async def get_skills():
    skills = await db.skills.find({}, {"_id": 0}).to_list(1000)
    for skill in skills:
        if isinstance(skill['created_at'], str):
            skill['created_at'] = datetime.fromisoformat(skill['created_at'])
    return skills

@api_router.delete("/skills/{skill_id}")
async def delete_skill(skill_id: str):
    result = await db.skills.delete_one({"id": skill_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Skill not found")
    await db.proficiency_rates.delete_many({"skill_id": skill_id})
    return {"message": "Skill deleted successfully"}


# Proficiency Rates Routes
@api_router.post("/proficiency-rates", response_model=ProficiencyRate)
async def create_proficiency_rate(input: ProficiencyRateCreate):
    # Check for duplicate: Technology + Skill + Base Location + Proficiency Level
    existing = await db.proficiency_rates.find_one({
        "skill_id": input.skill_id,
        "base_location_id": input.base_location_id,
        "proficiency_level": input.proficiency_level
    }, {"_id": 0})
    if existing:
        raise HTTPException(
            status_code=400, 
            detail="Rate already exists for this Skill, Location, and Proficiency Level combination"
        )
    
    rate_obj = ProficiencyRate(**input.model_dump())
    doc = rate_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.proficiency_rates.insert_one(doc)
    return rate_obj

@api_router.get("/proficiency-rates", response_model=List[ProficiencyRate])
async def get_proficiency_rates():
    rates = await db.proficiency_rates.find({}, {"_id": 0}).to_list(1000)
    for rate in rates:
        if isinstance(rate['created_at'], str):
            rate['created_at'] = datetime.fromisoformat(rate['created_at'])
    return rates

@api_router.delete("/proficiency-rates/{rate_id}")
async def delete_proficiency_rate(rate_id: str):
    result = await db.proficiency_rates.delete_one({"id": rate_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Proficiency rate not found")
    return {"message": "Proficiency rate deleted successfully"}

@api_router.put("/proficiency-rates/{rate_id}")
async def update_proficiency_rate(rate_id: str, avg_monthly_salary: float):
    """Update only the salary of a proficiency rate"""
    if avg_monthly_salary <= 0:
        raise HTTPException(status_code=400, detail="Salary must be positive")
    
    result = await db.proficiency_rates.update_one(
        {"id": rate_id},
        {"$set": {"avg_monthly_salary": avg_monthly_salary}}
    )
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Proficiency rate not found")
    
    updated = await db.proficiency_rates.find_one({"id": rate_id}, {"_id": 0})
    return updated


# Sales Manager Routes
@api_router.post("/sales-managers", response_model=SalesManager)
async def create_sales_manager(input: SalesManagerCreate):
    manager_obj = SalesManager(**input.model_dump())
    doc = manager_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.sales_managers.insert_one(doc)
    return manager_obj


@api_router.get("/sales-managers", response_model=List[SalesManager])
async def get_sales_managers(active_only: bool = False):
    query = {"is_active": True} if active_only else {}
    managers = await db.sales_managers.find(query, {"_id": 0}).to_list(1000)
    for manager in managers:
        if isinstance(manager.get('created_at'), str):
            manager['created_at'] = datetime.fromisoformat(manager['created_at'])
    return managers


@api_router.get("/sales-managers/{manager_id}", response_model=SalesManager)
async def get_sales_manager(manager_id: str):
    manager = await db.sales_managers.find_one({"id": manager_id}, {"_id": 0})
    if not manager:
        raise HTTPException(status_code=404, detail="Sales Manager not found")
    if isinstance(manager.get('created_at'), str):
        manager['created_at'] = datetime.fromisoformat(manager['created_at'])
    return manager


@api_router.put("/sales-managers/{manager_id}", response_model=SalesManager)
async def update_sales_manager(manager_id: str, input: SalesManagerUpdate):
    existing = await db.sales_managers.find_one({"id": manager_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Sales Manager not found")
    
    update_data = input.model_dump(exclude_unset=True)
    if update_data:
        await db.sales_managers.update_one({"id": manager_id}, {"$set": update_data})
    
    updated = await db.sales_managers.find_one({"id": manager_id}, {"_id": 0})
    if isinstance(updated.get('created_at'), str):
        updated['created_at'] = datetime.fromisoformat(updated['created_at'])
    return updated


@api_router.delete("/sales-managers/{manager_id}")
async def delete_sales_manager(manager_id: str):
    result = await db.sales_managers.delete_one({"id": manager_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Sales Manager not found")
    return {"message": "Sales Manager deleted successfully"}


# Projects Routes
async def generate_project_number():
    """Generate a unique project number like PRJ-0001"""
    last_project = await db.projects.find_one(
        {"project_number": {"$regex": "^PRJ-"}},
        {"project_number": 1},
        sort=[("project_number", -1)]
    )
    if last_project and last_project.get("project_number"):
        try:
            last_num = int(last_project["project_number"].split("-")[1])
            return f"PRJ-{str(last_num + 1).zfill(4)}"
        except (ValueError, IndexError):
            pass
    return "PRJ-0001"

@api_router.post("/projects", response_model=Project)
@api_router.post("/projects", response_model=Project)
async def create_project(input: ProjectCreate, user: dict = Depends(require_auth)):
    project_number = await generate_project_number()
    project_data = input.model_dump()
    project_data["project_number"] = project_number
    project_data["version"] = 1
    project_data["is_latest_version"] = True
    # Ensure waves is a list (can be None from input)
    if project_data.get("waves") is None:
        project_data["waves"] = []
    # Add audit fields
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        project_data["created_by_id"] = current_user.get("id", "")
        project_data["created_by_name"] = current_user.get("name", "")
        project_data["created_by_email"] = current_user.get("email", "")
    project_obj = Project(**project_data)
    doc = project_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    doc['updated_at'] = doc['updated_at'].isoformat()
    await db.projects.insert_one(doc)
    
    # Create audit log for project creation
    if current_user:
        await create_audit_log(
            user=current_user,
            action="created",
            entity_type="project",
            entity_id=project_obj.id,
            entity_name=project_obj.name,
            project_id=project_obj.id,
            project_number=project_obj.project_number,
            project_name=project_obj.name,
            metadata={"version": project_obj.version}
        )
    
    return project_obj

@api_router.get("/projects", response_model=List[Project])
async def get_projects(latest_only: bool = True):
    # Handle legacy data: show projects where is_latest_version is True OR not set
    # Exclude archived projects
    if latest_only:
        query = {
            "$and": [
                {"$or": [{"is_latest_version": True}, {"is_latest_version": {"$exists": False}}]},
                {"$or": [{"is_archived": False}, {"is_archived": {"$exists": False}}]}
            ]
        }
    else:
        query = {"$or": [{"is_archived": False}, {"is_archived": {"$exists": False}}]}
    projects = await db.projects.find(query, {"_id": 0}).to_list(1000)
    for project in projects:
        if isinstance(project.get('created_at'), str):
            project['created_at'] = datetime.fromisoformat(project['created_at'])
        if isinstance(project.get('updated_at'), str):
            project['updated_at'] = datetime.fromisoformat(project['updated_at'])
    return projects


@api_router.get("/projects/archived")
async def get_archived_projects():
    """Get all archived projects"""
    projects = await db.projects.find(
        {"is_archived": True, "is_latest_version": True},
        {"_id": 0}
    ).sort("archived_at", -1).to_list(500)
    
    for p in projects:
        if isinstance(p.get('created_at'), str):
            p['created_at'] = datetime.fromisoformat(p['created_at'])
        if isinstance(p.get('updated_at'), str):
            p['updated_at'] = datetime.fromisoformat(p['updated_at'])
    return projects


@api_router.get("/projects/{project_id}", response_model=Project)
async def get_project(project_id: str):
    project = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    if isinstance(project.get('created_at'), str):
        project['created_at'] = datetime.fromisoformat(project['created_at'])
    if isinstance(project.get('updated_at'), str):
        project['updated_at'] = datetime.fromisoformat(project['updated_at'])
    return project

@api_router.get("/projects/{project_id}/versions", response_model=List[Project])
async def get_project_versions(project_id: str):
    """Get all versions of a project"""
    project = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Find the root project number
    project_number = project.get("project_number", "")
    if not project_number:
        return [project]
    
    # Get all versions with same project number
    versions = await db.projects.find(
        {"project_number": project_number},
        {"_id": 0}
    ).sort("version", -1).to_list(100)
    
    for v in versions:
        if isinstance(v.get('created_at'), str):
            v['created_at'] = datetime.fromisoformat(v['created_at'])
        if isinstance(v.get('updated_at'), str):
            v['updated_at'] = datetime.fromisoformat(v['updated_at'])
    return versions

@api_router.put("/projects/{project_id}", response_model=Project)
async def update_project(project_id: str, input: ProjectUpdate, user: dict = Depends(get_current_user)):
    existing = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Project not found")
    
    update_data = input.model_dump(exclude_unset=True)
    update_data['updated_at'] = datetime.now(timezone.utc).isoformat()
    
    # Detect changes for audit log
    fields_to_track = ["name", "description", "status", "profit_margin_percentage", "customer_id", "customer_name", "version_notes"]
    changes = detect_changes(existing, update_data, fields_to_track)
    
    await db.projects.update_one({"id": project_id}, {"$set": update_data})
    
    # Create audit log for update
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user and changes:
        await create_audit_log(
            user=current_user,
            action="updated",
            entity_type="project",
            entity_id=project_id,
            entity_name=existing.get("name", ""),
            project_id=project_id,
            project_number=existing.get("project_number", ""),
            project_name=existing.get("name", ""),
            changes=changes
        )
    
    updated = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if isinstance(updated.get('created_at'), str):
        updated['created_at'] = datetime.fromisoformat(updated['created_at'])
    if isinstance(updated.get('updated_at'), str):
        updated['updated_at'] = datetime.fromisoformat(updated['updated_at'])
    return updated


@api_router.post("/projects/{project_id}/archive")
async def archive_project(project_id: str, user: dict = Depends(get_current_user)):
    """Archive a project"""
    existing = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Project not found")
    
    await db.projects.update_one(
        {"id": project_id},
        {"$set": {
            "is_archived": True,
            "archived_at": datetime.now(timezone.utc).isoformat(),
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    # Create audit log
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="archived",
            entity_type="project",
            entity_id=project_id,
            entity_name=existing.get("name", ""),
            project_id=project_id,
            project_number=existing.get("project_number", ""),
            project_name=existing.get("name", "")
        )
    
    return {"message": "Project archived successfully"}


@api_router.post("/projects/{project_id}/unarchive")
async def unarchive_project(project_id: str, user: dict = Depends(get_current_user)):
    """Unarchive a project"""
    existing = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Project not found")
    
    await db.projects.update_one(
        {"id": project_id},
        {"$set": {
            "is_archived": False,
            "archived_at": None,
            "updated_at": datetime.now(timezone.utc).isoformat()
        }}
    )
    
    # Create audit log
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="unarchived",
            entity_type="project",
            entity_id=project_id,
            entity_name=existing.get("name", ""),
            project_id=project_id,
            project_number=existing.get("project_number", ""),
            project_name=existing.get("name", "")
        )
    
    return {"message": "Project unarchived successfully"}


@api_router.post("/projects/{project_id}/new-version", response_model=Project)
async def create_new_version(project_id: str, input: ProjectUpdate, user: dict = Depends(get_current_user)):
    """Create a new version of an existing project"""
    existing = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Mark current as not latest
    await db.projects.update_one(
        {"id": project_id},
        {"$set": {"is_latest_version": False, "updated_at": datetime.now(timezone.utc).isoformat()}}
    )
    
    # Get current max version for this project number
    project_number = existing.get("project_number", "")
    max_version = await db.projects.find_one(
        {"project_number": project_number},
        {"version": 1},
        sort=[("version", -1)]
    )
    new_version = (max_version.get("version", 1) if max_version else 1) + 1
    
    # Create new version
    new_project_data = {**existing}
    new_project_data["id"] = str(uuid.uuid4())
    new_project_data["version"] = new_version
    new_project_data["is_latest_version"] = True
    new_project_data["parent_project_id"] = project_id
    new_project_data["created_at"] = datetime.now(timezone.utc)
    new_project_data["updated_at"] = datetime.now(timezone.utc)
    
    # Reset status and approval fields for new version
    new_project_data["status"] = "draft"
    new_project_data["approver_email"] = ""
    new_project_data["approval_comments"] = ""
    new_project_data["submitted_at"] = None
    new_project_data["approved_at"] = None
    
    # Apply updates (but don't allow status to be overwritten)
    update_data = input.model_dump(exclude_unset=True)
    # Remove status from update_data to prevent overwriting draft status
    update_data.pop("status", None)
    update_data.pop("approver_email", None)
    update_data.pop("approval_comments", None)
    update_data.pop("submitted_at", None)
    update_data.pop("approved_at", None)
    
    for key, value in update_data.items():
        if value is not None:
            new_project_data[key] = value
    
    project_obj = Project(**new_project_data)
    doc = project_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    doc['updated_at'] = doc['updated_at'].isoformat()
    await db.projects.insert_one(doc)
    
    # Create audit log for new version
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="version_created",
            entity_type="project",
            entity_id=project_obj.id,
            entity_name=project_obj.name,
            project_id=project_obj.id,
            project_number=project_obj.project_number,
            project_name=project_obj.name,
            metadata={
                "new_version": new_version,
                "previous_version": existing.get("version", 1),
                "version_notes": update_data.get("version_notes", "")
            }
        )
    
    return project_obj

@api_router.post("/projects/{project_id}/clone", response_model=Project)
async def clone_project(project_id: str, user: dict = Depends(require_auth)):
    """Clone a project as a new project with new project number"""
    existing = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Generate new project number
    new_project_number = await generate_project_number()
    
    # Get current user info
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    
    # Create cloned project
    cloned_data = {**existing}
    cloned_data["id"] = str(uuid.uuid4())
    cloned_data["project_number"] = new_project_number
    cloned_data["version"] = 1
    cloned_data["is_latest_version"] = True
    cloned_data["parent_project_id"] = ""
    cloned_data["name"] = f"{existing.get('name', 'Project')} (Copy)"
    cloned_data["status"] = "draft"  # Reset status to draft when cloning
    cloned_data["approver_email"] = ""  # Clear approval fields
    cloned_data["approval_comments"] = ""
    cloned_data["submitted_at"] = None
    cloned_data["approved_at"] = None
    cloned_data["created_at"] = datetime.now(timezone.utc)
    cloned_data["updated_at"] = datetime.now(timezone.utc)
    # Set audit fields to current user (cloner becomes owner)
    if current_user:
        cloned_data["created_by_id"] = current_user.get("id", "")
        cloned_data["created_by_name"] = current_user.get("name", "")
        cloned_data["created_by_email"] = current_user.get("email", "")
    
    project_obj = Project(**cloned_data)
    doc = project_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    doc['updated_at'] = doc['updated_at'].isoformat()
    await db.projects.insert_one(doc)
    
    # Create audit log for clone
    if current_user:
        await create_audit_log(
            user=current_user,
            action="cloned",
            entity_type="project",
            entity_id=project_obj.id,
            entity_name=project_obj.name,
            project_id=project_obj.id,
            project_number=project_obj.project_number,
            project_name=project_obj.name,
            metadata={
                "cloned_from_id": project_id,
                "cloned_from_number": existing.get("project_number", ""),
                "cloned_from_name": existing.get("name", "")
            }
        )
    
    return project_obj

@api_router.delete("/projects/{project_id}")
async def delete_project(project_id: str, user: dict = Depends(get_current_user)):
    existing = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not existing:
        raise HTTPException(status_code=404, detail="Project not found")
    
    result = await db.projects.delete_one({"id": project_id})
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Project not found")
    
    # Create audit log for delete
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="deleted",
            entity_type="project",
            entity_id=project_id,
            entity_name=existing.get("name", ""),
            project_id=project_id,
            project_number=existing.get("project_number", ""),
            project_name=existing.get("name", "")
        )
    
    return {"message": "Project deleted successfully"}


# Template endpoints
@api_router.get("/templates")
async def get_templates():
    """Get all project templates"""
    templates = await db.projects.find(
        {"is_template": True},
        {"_id": 0}
    ).sort("template_name", 1).to_list(100)
    return templates

@api_router.post("/projects/{project_id}/save-as-template")
async def save_as_template(project_id: str, template_name: str):
    """Mark a project as a template"""
    project = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    if not template_name:
        raise HTTPException(status_code=400, detail="Template name is required")
    
    # Check if template name already exists
    existing = await db.projects.find_one({"is_template": True, "template_name": template_name})
    if existing:
        raise HTTPException(status_code=400, detail="Template with this name already exists")
    
    await db.projects.update_one(
        {"id": project_id},
        {"$set": {"is_template": True, "template_name": template_name}}
    )
    
    return {"message": f"Project saved as template: {template_name}"}

@api_router.post("/projects/{project_id}/remove-template")
async def remove_template(project_id: str):
    """Remove template flag from a project"""
    result = await db.projects.update_one(
        {"id": project_id},
        {"$set": {"is_template": False, "template_name": ""}}
    )
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Project not found")
    return {"message": "Template removed"}

@api_router.post("/projects/create-from-template/{template_id}")
async def create_from_template(template_id: str, user: dict = Depends(require_auth)):
    """Create a new project from a template"""
    template = await db.projects.find_one({"id": template_id, "is_template": True}, {"_id": 0})
    if not template:
        raise HTTPException(status_code=404, detail="Template not found")
    
    # Get current user info
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    
    # Get next project number
    last_project = await db.projects.find_one(
        {"project_number": {"$regex": "^PRJ-"}},
        sort=[("project_number", -1)]
    )
    if last_project and last_project.get("project_number"):
        last_num = int(last_project["project_number"].split("-")[1])
        new_project_number = f"PRJ-{str(last_num + 1).zfill(4)}"
    else:
        new_project_number = "PRJ-0001"
    
    # Create new project from template
    new_project_data = {**template}
    new_project_data["id"] = str(uuid.uuid4())
    new_project_data["project_number"] = new_project_number
    new_project_data["version"] = 1
    new_project_data["version_notes"] = f"Created from template: {template.get('template_name', 'Unknown')}"
    new_project_data["name"] = f"{template.get('name', 'Project')} (from template)"
    new_project_data["is_template"] = False
    new_project_data["template_name"] = ""
    new_project_data["is_latest_version"] = True
    new_project_data["parent_project_id"] = ""
    new_project_data["status"] = "draft"
    new_project_data["approver_email"] = ""
    new_project_data["approval_comments"] = ""
    new_project_data["submitted_at"] = None
    new_project_data["approved_at"] = None
    new_project_data["customer_id"] = ""
    new_project_data["customer_name"] = ""
    new_project_data["created_at"] = datetime.now(timezone.utc)
    new_project_data["updated_at"] = datetime.now(timezone.utc)
    # Set audit fields
    if current_user:
        new_project_data["created_by_id"] = current_user.get("id", "")
        new_project_data["created_by_name"] = current_user.get("name", "")
        new_project_data["created_by_email"] = current_user.get("email", "")
    
    # Generate new IDs for waves and allocations
    for wave in new_project_data.get("waves", []):
        wave["id"] = str(uuid.uuid4())
        for alloc in wave.get("grid_allocations", []):
            alloc["id"] = str(uuid.uuid4())
    
    project_obj = Project(**new_project_data)
    doc = project_obj.model_dump()
    doc["created_at"] = doc["created_at"].isoformat() if isinstance(doc["created_at"], datetime) else doc["created_at"]
    doc["updated_at"] = doc["updated_at"].isoformat() if isinstance(doc["updated_at"], datetime) else doc["updated_at"]
    
    await db.projects.insert_one(doc)
    return project_obj


# Submit project for review
@api_router.post("/projects/{project_id}/submit-for-review")
async def submit_for_review(project_id: str, approver_email: str, user: dict = Depends(require_auth)):
    project = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    if not approver_email:
        raise HTTPException(status_code=400, detail="Approver email is required")
    
    old_status = project.get("status", "draft")
    update_data = {
        "status": "in_review",
        "approver_email": approver_email,
        "submitted_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.projects.update_one({"id": project_id}, {"$set": update_data})
    
    # Create audit log for status change
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="status_change",
            entity_type="project",
            entity_id=project_id,
            entity_name=project.get("name", ""),
            project_id=project_id,
            project_number=project.get("project_number", ""),
            project_name=project.get("name", ""),
            changes=[{"field": "status", "old_value": old_status, "new_value": "in_review"}],
            metadata={"approver_email": approver_email}
        )
    
    # Create notification for approver
    notification = Notification(
        user_email=approver_email,
        type="review_request",
        title="New Project Review Request",
        message=f"Project {project.get('project_number', '')} '{project.get('name', '')}' has been submitted for your review.",
        project_id=project_id,
        project_number=project.get("project_number", "")
    )
    notif_doc = notification.model_dump()
    notif_doc['created_at'] = notif_doc['created_at'].isoformat()
    await db.notifications.insert_one(notif_doc)
    
    return {"message": "Project submitted for review", "status": "in_review"}


# Approve project
@api_router.post("/projects/{project_id}/approve")
async def approve_project(project_id: str, comments: str = "", user: dict = Depends(require_auth)):
    project = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    old_status = project.get("status", "in_review")
    update_data = {
        "status": "approved",
        "approval_comments": comments,
        "approved_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.projects.update_one({"id": project_id}, {"$set": update_data})
    
    # Create audit log for approval
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="status_change",
            entity_type="project",
            entity_id=project_id,
            entity_name=project.get("name", ""),
            project_id=project_id,
            project_number=project.get("project_number", ""),
            project_name=project.get("name", ""),
            changes=[{"field": "status", "old_value": old_status, "new_value": "approved"}],
            metadata={"comments": comments}
        )
    
    # Create notification for submitter (using customer name as placeholder)
    notification = Notification(
        user_email=project.get("approver_email", ""),
        type="approved",
        title="Project Approved",
        message=f"Project {project.get('project_number', '')} '{project.get('name', '')}' has been approved.",
        project_id=project_id,
        project_number=project.get("project_number", "")
    )
    notif_doc = notification.model_dump()
    notif_doc['created_at'] = notif_doc['created_at'].isoformat()
    await db.notifications.insert_one(notif_doc)
    
    return {"message": "Project approved", "status": "approved"}


# Reject project
@api_router.post("/projects/{project_id}/reject")
async def reject_project(project_id: str, comments: str = "", user: dict = Depends(require_auth)):
    project = await db.projects.find_one({"id": project_id}, {"_id": 0})
    if not project:
        raise HTTPException(status_code=404, detail="Project not found")
    
    old_status = project.get("status", "in_review")
    update_data = {
        "status": "rejected",
        "approval_comments": comments,
        "updated_at": datetime.now(timezone.utc).isoformat()
    }
    
    await db.projects.update_one({"id": project_id}, {"$set": update_data})
    
    # Create audit log for rejection
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    if current_user:
        await create_audit_log(
            user=current_user,
            action="status_change",
            entity_type="project",
            entity_id=project_id,
            entity_name=project.get("name", ""),
            project_id=project_id,
            project_number=project.get("project_number", ""),
            project_name=project.get("name", ""),
            changes=[{"field": "status", "old_value": old_status, "new_value": "rejected"}],
            metadata={"comments": comments}
        )
    
    # Create notification
    notification = Notification(
        user_email=project.get("approver_email", ""),
        type="rejected",
        title="Project Rejected",
        message=f"Project {project.get('project_number', '')} '{project.get('name', '')}' has been rejected. Comments: {comments}",
        project_id=project_id,
        project_number=project.get("project_number", "")
    )
    notif_doc = notification.model_dump()
    notif_doc['created_at'] = notif_doc['created_at'].isoformat()
    await db.notifications.insert_one(notif_doc)
    
    return {"message": "Project rejected", "status": "rejected"}


# Notifications endpoints
@api_router.get("/notifications")
async def get_notifications(user_email: str = None, unread_only: bool = False):
    query = {}
    if user_email:
        query["user_email"] = user_email
    if unread_only:
        query["is_read"] = False
    
    notifications = await db.notifications.find(query, {"_id": 0}).sort("created_at", -1).to_list(100)
    for notif in notifications:
        if isinstance(notif.get('created_at'), str):
            notif['created_at'] = datetime.fromisoformat(notif['created_at'])
    return notifications


@api_router.put("/notifications/{notification_id}/read")
async def mark_notification_read(notification_id: str):
    result = await db.notifications.update_one(
        {"id": notification_id},
        {"$set": {"is_read": True}}
    )
    if result.matched_count == 0:
        raise HTTPException(status_code=404, detail="Notification not found")
    return {"message": "Notification marked as read"}


@api_router.put("/notifications/mark-all-read")
async def mark_all_notifications_read(user_email: str = None):
    query = {}
    if user_email:
        query["user_email"] = user_email
    await db.notifications.update_many(query, {"$set": {"is_read": True}})
    return {"message": "All notifications marked as read"}


# Audit Log endpoints
@api_router.get("/audit-logs")
async def get_audit_logs(
    project_id: Optional[str] = None,
    entity_type: Optional[str] = None,
    action: Optional[str] = None,
    user_email: Optional[str] = None,
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    limit: int = 100,
    user: dict = Depends(get_current_user)
):
    """Get audit logs with optional filters - admin only for all logs"""
    current_user = await db.users.find_one({"id": user["user_id"]}, {"_id": 0})
    
    query = {}
    
    if project_id:
        query["project_id"] = project_id
    if entity_type:
        query["entity_type"] = entity_type
    if action:
        query["action"] = action
    if user_email:
        query["user_email"] = user_email
    
    # Date range filter
    if date_from or date_to:
        date_filter = {}
        if date_from:
            date_filter["$gte"] = f"{date_from}T00:00:00"
        if date_to:
            date_filter["$lte"] = f"{date_to}T23:59:59"
        if date_filter:
            query["timestamp"] = date_filter
    
    # Non-admins can only see their own logs or logs for projects they own
    if current_user and current_user.get("role") != "admin":
        query["$or"] = [
            {"user_id": current_user.get("id")},
            {"project_id": {"$in": await get_user_project_ids(current_user.get("id"))}}
        ]
    
    logs = await db.audit_logs.find(query, {"_id": 0}).sort("timestamp", -1).limit(limit).to_list(limit)
    
    for log in logs:
        if isinstance(log.get('timestamp'), str):
            log['timestamp'] = datetime.fromisoformat(log['timestamp'])
    
    return logs


async def get_user_project_ids(user_id: str) -> List[str]:
    """Helper to get project IDs owned by a user"""
    projects = await db.projects.find({"created_by_id": user_id}, {"id": 1}).to_list(1000)
    return [p["id"] for p in projects]


@api_router.get("/audit-logs/project/{project_id}")
async def get_project_audit_logs(project_id: str, user: dict = Depends(get_current_user)):
    """Get all audit logs for a specific project"""
    logs = await db.audit_logs.find(
        {"project_id": project_id},
        {"_id": 0}
    ).sort("timestamp", -1).to_list(500)
    
    for log in logs:
        if isinstance(log.get('timestamp'), str):
            log['timestamp'] = datetime.fromisoformat(log['timestamp'])
    
    return logs


@api_router.get("/audit-logs/summary")
async def get_audit_summary(user: dict = Depends(require_admin)):
    """Get audit log summary statistics - admin only"""
    # Count by action type
    action_counts = await db.audit_logs.aggregate([
        {"$group": {"_id": "$action", "count": {"$sum": 1}}}
    ]).to_list(100)
    
    # Count by user
    user_counts = await db.audit_logs.aggregate([
        {"$group": {"_id": "$user_email", "count": {"$sum": 1}}},
        {"$sort": {"count": -1}},
        {"$limit": 10}
    ]).to_list(10)
    
    # Recent activity (last 7 days)
    seven_days_ago = (datetime.now(timezone.utc) - timedelta(days=7)).isoformat()
    recent_count = await db.audit_logs.count_documents({"timestamp": {"$gte": seven_days_ago}})
    
    return {
        "action_counts": {item["_id"]: item["count"] for item in action_counts},
        "top_users": [{"email": item["_id"], "count": item["count"]} for item in user_counts],
        "recent_activity_count": recent_count,
        "total_logs": await db.audit_logs.count_documents({})
    }


# Dashboard analytics endpoint
@api_router.get("/dashboard/analytics")
async def get_dashboard_analytics(
    date_from: Optional[str] = None,
    date_to: Optional[str] = None,
    customer_id: Optional[str] = None
):
    # Build query based on filters
    query = {}
    
    # Date range filter - stored dates are ISO strings, so compare as strings
    if date_from or date_to:
        date_filter = {}
        if date_from:
            # Frontend sends YYYY-MM-DD format, convert to ISO string for comparison
            date_filter["$gte"] = f"{date_from}T00:00:00"
        if date_to:
            # Add end of day for date_to
            date_filter["$lte"] = f"{date_to}T23:59:59"
        if date_filter:
            query["created_at"] = date_filter
    
    # Customer filter
    if customer_id:
        query["customer_id"] = customer_id
    
    # Get filtered projects
    projects = await db.projects.find(query, {"_id": 0}).to_list(1000)
    
    # Calculate metrics
    total_projects = len(projects)
    total_revenue = 0
    projects_by_status = {"draft": 0, "in_review": 0, "approved": 0, "rejected": 0}
    projects_by_month = {}
    customer_revenue = {}
    
    for project in projects:
        status = project.get("status", "draft")
        projects_by_status[status] = projects_by_status.get(status, 0) + 1
        
        # Calculate project value
        project_value = 0
        waves = project.get("waves", [])
        profit_margin = project.get("profit_margin_percentage", 35)
        
        for wave in waves:
            config = wave.get("logistics_config", {})
            allocations = wave.get("grid_allocations", [])
            
            wave_base_cost = 0
            wave_logistics = 0
            traveling_mm = 0
            traveling_count = 0
            
            for alloc in allocations:
                mm = sum(alloc.get("phase_allocations", {}).values())
                salary_cost = alloc.get("avg_monthly_salary", 0) * mm
                overhead = salary_cost * (alloc.get("overhead_percentage", 0) / 100)
                wave_base_cost += salary_cost + overhead
                
                if alloc.get("travel_required", False):
                    traveling_mm += mm
                    traveling_count += 1
            
            # Calculate wave logistics for traveling resources
            if traveling_count > 0:
                per_diem = traveling_mm * config.get("per_diem_daily", 50) * config.get("per_diem_days", 30)
                accommodation = traveling_mm * config.get("accommodation_daily", 80) * config.get("accommodation_days", 30)
                conveyance = traveling_mm * config.get("local_conveyance_daily", 15) * config.get("local_conveyance_days", 21)
                flights = traveling_count * config.get("flight_cost_per_trip", 450) * config.get("num_trips", 6)
                visa = traveling_count * config.get("visa_medical_per_trip", 400) * config.get("num_trips", 6)
                subtotal = per_diem + accommodation + conveyance + flights + visa
                contingency = subtotal * (config.get("contingency_percentage", 5) / 100)
                wave_logistics = subtotal + contingency
            
            project_value += wave_base_cost + wave_logistics
        
        # Apply profit margin
        if profit_margin < 100:
            project_value = project_value / (1 - profit_margin / 100)
        
        total_revenue += project_value
        
        # Group by customer
        customer_name = project.get("customer_name", "Unknown")
        customer_revenue[customer_name] = customer_revenue.get(customer_name, 0) + project_value
        
        # Group by month
        created_at = project.get("created_at")
        if created_at:
            if isinstance(created_at, str):
                created_at = datetime.fromisoformat(created_at)
            month_key = created_at.strftime("%Y-%m")
            if month_key not in projects_by_month:
                projects_by_month[month_key] = {"count": 0, "revenue": 0}
            projects_by_month[month_key]["count"] += 1
            projects_by_month[month_key]["revenue"] += project_value
    
    # Convert to sorted list for charts
    monthly_data = [
        {"month": k, "count": v["count"], "revenue": v["revenue"]}
        for k, v in sorted(projects_by_month.items())
    ]
    
    # Top 5 customers by revenue
    top_customers = sorted(
        [{"name": k, "revenue": v} for k, v in customer_revenue.items()],
        key=lambda x: x["revenue"],
        reverse=True
    )[:5]
    
    return {
        "total_projects": total_projects,
        "total_revenue": total_revenue,
        "projects_by_status": projects_by_status,
        "monthly_data": monthly_data,
        "top_customers": top_customers
    }


app.include_router(api_router)

app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=os.environ.get('CORS_ORIGINS', '*').split(','),
    allow_methods=["*"],
    allow_headers=["*"],
)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

@app.on_event("shutdown")
async def shutdown_db_client():
    client.close()